//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace RolexDemo {
    using System;
    using System.IO;
    using System.Collections.Generic;
    using System.Text;
    
    ///  <summary>
    ///  Reference implementation for generated shared code
    ///  </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Rolex", "0.9.0.0")]
    internal struct Token {
        ///  <summary>
        ///  Indicates the line where the token occurs
        ///  </summary>
        public int Line;
        ///  <summary>
        ///  Indicates the column where the token occurs
        ///  </summary>
        public int Column;
        ///  <summary>
        ///  Indicates the character index where the token occurs
        ///  </summary>
        public long AbsoluteIndex;
        ///  <summary>
        ///  Indicates the position where the token occurs
        ///  </summary>
        public long Position;
        ///  <summary>
        ///  Indicates the symbol id or -1 for the error symbol
        ///  </summary>
        public int SymbolId;
        ///  <summary>
        ///  Indicates the value of the token
        ///  </summary>
        public string Value;
    }
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Rolex", "0.9.0.0")]
    internal class TextReaderEnumerator : Object, IEnumerator<char> {
        private int _state;
        private char _current;
        private TextReader _reader;
        internal TextReaderEnumerator(TextReader reader) {
            this._reader = reader;
            this._state = -1;
        }
        ///  <summary>
        ///  Gets the current character under the cursor
        ///  </summary>
        ///  <exception cref="ObjectDisposedException">The enumerator is disposed</exception>
        public char Current {
            get {
                if ((this._state == -3)) {
                    throw new ObjectDisposedException("The enumerator was disposed");
                }
                if (((this._state == -1) 
                            || (this._state == -2))) {
                    throw new InvalidOperationException("The enumerator is not positioned on an element.");
                }
                return this._current;
            }
        }
        object System.Collections.IEnumerator.Current {
            get {
                return this.Current;
            }
        }
        ///  <summary>
        ///  Disposes of the enumerator
        ///  </summary>
        public void Dispose() {
            if ((this._state == -3)) {
                return;
            }
            this._state = -3;
        }
        void IDisposable.Dispose() {
            this.Dispose();
        }
        ///  <summary>
        ///  Moves to the next element
        ///  </summary>
        ///  <returns>True if successful, false if no more data</returns>
        ///  <exception cref="ObjectDisposedException">The enumerator was disposed</exception>
        public bool MoveNext() {
            if ((this._state == -3)) {
                throw new ObjectDisposedException("The enumerator was disposed");
            }
            if ((this._state == -2)) {
                return false;
            }
            int i = this._reader.Read();
            if ((i == -1)) {
                this._state = -2;
                return false;
            }
            this._state = 0;
            this._current = System.Convert.ToChar(i);
            return true;
        }
        bool System.Collections.IEnumerator.MoveNext() {
            return this.MoveNext();
        }
        ///  <summary>
        ///  Resets the enumerator
        ///  </summary>
        ///  <remarks>Not supported</remarks>
        ///  <exception cref="ObjectDisposedException">The enumerator is disposed</exception>
        ///  <exception cref="NotSupportedException">The operation is not supported (always throws)</exception>
        public void Reset() {
            if ((this._state == -3)) {
                throw new ObjectDisposedException("The enumerator was disposed");
            }
            if ((this._state == -1)) {
                return;
            }
            throw new NotSupportedException();
        }
        void System.Collections.IEnumerator.Reset() {
            this.Reset();
        }
    }
    ///  <summary>
    ///  Gets an enumerable instance over a TextReader
    ///  </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Rolex", "0.9.0.0")]
    internal class TextReaderEnumerable : Object, IEnumerable<char> {
        private TextReader _reader;
        private int _state;
        ///  <summary>
        ///  Creates a new instance
        ///  </summary>
        ///  <param name="reader">The TextReader</param>
        public TextReaderEnumerable(TextReader reader) {
            this._reader = reader;
            this._state = -1;
        }
        ///  <summary>
        ///  Gets the enumerator
        ///  </summary>
        ///  <remarks>This can only be called once</remarks>
        ///  <returns>A new enumerator</returns>
        ///  <exception cref="InvalidOperationException">The operation cannot be done more than once</exception>
        public IEnumerator<char> GetEnumerator() {
            if ((false 
                        == (this._state == -1))) {
                throw new InvalidOperationException("The collection cannot be enumerated more than once.");
            }
            TextReaderEnumerator result = new TextReaderEnumerator(this._reader);
            this._state = 0;
            return result;
        }
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
            return this.GetEnumerator();
        }
    }
    ///  <summary>
    ///  Reference Implementation for generated shared code
    ///  </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Rolex", "0.9.0.0")]
    internal class TableTokenizer : object, IEnumerable<Token> {
        ///  <summary>
        ///  The symbol id for an error
        ///  </summary>
        public const int ErrorSymbol = -1;
        //  our state table
        private int[] _dfaTable;
        //  our block ends (specified like comment<blockEnd="*/">="/*" in a rolex spec file)
        private int[][] _blockEnds;
        //  our node flags. Currently only used for the hidden attribute
        private int[] _nodeFlags;
        //  the input cursor. We can get this from a string, a char array, or some other source.
        private IEnumerable<char> _input;
        private int _tabWidth;
        ///  <summary>
        ///  Indicates the width of a tab stop
        ///  </summary>
        public int TabWidth {
            get {
                return this._tabWidth;
            }
            set {
                if ((this._tabWidth <= 0)) {
                    this._tabWidth = 4;
                }
                this._tabWidth = value;
            }
        }
        ///  <summary>
        ///  Retrieves an enumerator that can be used to iterate over the tokens
        ///  </summary>
        ///  <returns>An enumerator that can be used to iterate over the tokens</returns>
        public IEnumerator<Token> GetEnumerator() {
            TableTokenizerEnumerator result = new TableTokenizerEnumerator(this._dfaTable, this._blockEnds, this._nodeFlags, this._input.GetEnumerator());
            result.TabWidth = this._tabWidth;
            return result;
        }
        //  legacy collection support (required)
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
            return this.GetEnumerator();
        }
        ///  <summary>
        ///  Constructs a new instance
        ///  </summary>
        ///  <param name="dfaTable">The DFA state table to use</param>
        ///  <param name="blockEnds">The block ends table</param>
        ///  <param name="nodeFlags">The node flags table</param>
        ///  <param name="input">The input character sequence</param>
        public TableTokenizer(int[] dfaTable, int[][] blockEnds, int[] nodeFlags, IEnumerable<char> input) {
            if ((null == dfaTable)) {
                throw new ArgumentNullException("dfaTable");
            }
            if ((null == blockEnds)) {
                throw new ArgumentNullException("blockEnds");
            }
            if ((null == nodeFlags)) {
                throw new ArgumentNullException("nodeFlags");
            }
            if ((null == input)) {
                throw new ArgumentNullException("input");
            }
            this._dfaTable = dfaTable;
            this._blockEnds = blockEnds;
            this._nodeFlags = nodeFlags;
            this._input = input;
        }
    }
    ///  <summary>
    ///  Enumerates tokens over a character enumerator
    ///  </summary>
    [System.CodeDom.Compiler.GeneratedCodeAttribute("Rolex", "0.9.0.0")]
    internal class TableTokenizerEnumerator : object, IEnumerator<Token> {
        private int _state;
        private Token _token;
        private int _ch;
        private int[] _dfa;
        private int[][] _blockEnds;
        private int[] _nodeFlags;
        private long _position;
        private long _absIndex;
        private int _line;
        private int _column;
        private int _tabWidth;
        private StringBuilder _capture = new StringBuilder();
        private IEnumerator<char> _inner;
        ///  <summary>
        ///  Constructs a new token enumerator
        ///  </summary>
        ///  <param name="dfa">The DFA to use</param>
        ///  <param name="blockEnds">The block end DFAs to use</param>
        ///  <param name="nodeFlags">The node flags</param>
        ///  <param name="inner">The character enumerator</param>
        public TableTokenizerEnumerator(int[] dfa, int[][] blockEnds, int[] nodeFlags, IEnumerator<char> inner) {
            this._position = 0;
            this._line = 1;
            this._column = 1;
            this._absIndex = 0;
            this._dfa = dfa;
            this._blockEnds = blockEnds;
            this._nodeFlags = nodeFlags;
            this._inner = inner;
            this._ch = -2;
            this._token.SymbolId = -2;
            this._state = -1;
            this._tabWidth = 4;
        }
        ///  <summary>
        ///  Indicates the width of the tab stops
        ///  </summary>
        public int TabWidth {
            get {
                return this._tabWidth;
            }
            set {
                if ((value <= 0)) {
                    this._tabWidth = 4;
                }
                else {
                    this._tabWidth = value;
                }
            }
        }
        ///  <summary>
        ///  Indicates the current token
        ///  </summary>
        public Token Current {
            get {
                if ((this._state == -3)) {
                    throw new ObjectDisposedException("The enumerator was disposed");
                }
                else {
                    if (((this._state == -2) 
                                || (this._state == -1))) {
                        throw new InvalidOperationException("The enumerator is not positioned on an element");
                    }
                }
                return this._token;
            }
        }
        //  legacy support
        object System.Collections.IEnumerator.Current {
            get {
                return this.Current;
            }
        }
        //  framework support
        void System.IDisposable.Dispose() {
            this.Dispose();
        }
        ///  <summary>
        ///  Disposes of the enumerator
        ///  </summary>
        public void Dispose() {
            if ((this._state == -3)) {
                return;
            }
            this._inner.Dispose();
            this._state = -3;
        }
        private bool _FetchNextInput() {
            if ((false == this._inner.MoveNext())) {
                this._ch = -1;
                return false;
            }
            char ch1 = this._inner.Current;
            if (char.IsHighSurrogate(ch1)) {
                if ((false == this._inner.MoveNext())) {
                    throw new IOException("The stream is not valid Unicode");
                }
                char ch2 = this._inner.Current;
                if ((false == char.IsLowSurrogate(ch2))) {
                    throw new IOException("The stream is not valid Unicode");
                }
                this._absIndex = (this._absIndex + 1);
                this._ch = char.ConvertToUtf32(ch1, ch2);
            }
            else {
                if ((ch1 == '\r')) {
                    this._column = 1;
                }
                else {
                    if ((ch1 == '\n')) {
                        this._line = (this._line + 1);
                        this._column = 1;
                    }
                    else {
                        if ((ch1 == '\t')) {
                            this._column = (((((this._column - 1) 
                                        / this._tabWidth) 
                                        + 1) 
                                        * this._tabWidth) 
                                        + 1);
                        }
                        else {
                            this._column = (this._column + 1);
                        }
                    }
                }
                this._ch = System.Convert.ToInt32(ch1);
            }
            this._position = (this._position + 1);
            this._absIndex = (this._absIndex + 1);
            return true;
        }
        //  supports the framework
        bool System.Collections.IEnumerator.MoveNext() {
            return this.MoveNext();
        }
        ///  <summary>
        ///  Moves to the next token
        ///  </summary>
        ///  <returns>True if successful, or false if there were not any more tokens</returns>
        ///  <exception cref="ObjectDisposedException">Thrown if the cobject was disposed of</exception>
        public bool MoveNext() {
            if ((this._state == -3)) {
                throw new ObjectDisposedException("The enumerator was disposed");
            }
            else {
                if ((this._state == -1)) {
                    this._state = 0;
                }
            }
            if ((this._state == 0)) {
                for (
                ; true; 
                ) {
                    if ((this._ch == -1)) {
                        this._state = -2;
                        return false;
                    }
                    this._Lex();
                    if ((this._token.SymbolId > -1)) {
                        if ((0 
                                    == (this._nodeFlags[this._token.SymbolId] & 1))) {
                            return true;
                        }
                    }
                    else {
                        return true;
                    }
                }
            }
            return false;
        }
        //  supports the framework
        void System.Collections.IEnumerator.Reset() {
            this.Reset();
        }
        ///  <summary>
        ///  Resets the enumerator
        ///  </summary>
        ///  <exception cref="ObjectDisposedException">The enumerator was disposed</exception>
        public void Reset() {
            if ((this._state == -3)) {
                throw new ObjectDisposedException("The enumerator was disposed");
            }
            this._state = -1;
            this._ch = -2;
            this._position = 0;
            this._absIndex = 0;
            this._line = 1;
            this._column = 1;
            this._token.SymbolId = -2;
        }
        ///  <summary>
        ///  Indicates the absolute character index of the cursor
        ///  </summary>
        public long AbsoluteIndex {
            get {
                if ((this._state == -3)) {
                    throw new ObjectDisposedException("The enumerator was disposed");
                }
                return this._absIndex;
            }
        }
        ///  <summary>
        ///  Indicates the position of the cursor
        ///  </summary>
        public long Position {
            get {
                if ((this._state == -3)) {
                    throw new ObjectDisposedException("The enumerator was disposed");
                }
                return this._position;
            }
        }
        ///  <summary>
        ///  Indicates the line of the cursor
        ///  </summary>
        public int Line {
            get {
                if ((this._state == -3)) {
                    throw new ObjectDisposedException("The enumerator was disposed");
                }
                return this._line;
            }
        }
        ///  <summary>
        ///  Indicates the column of the cursor
        ///  </summary>
        public int Column {
            get {
                return this._column;
            }
        }
        private bool _Lex() {
            int tlen;
            int tto;
            int prlen;
            int pmin;
            int pmax;
            int i;
            int j;
            int state = 0;
            int acc;
            long cursor_pos = this._position;
            int line = this._line;
            int column;
            if ((this._absIndex == 0)) {
                column = this._column;
            }
            else {
                column = (this._column - 1);
            }
            long absi = this._absIndex;
            if ((this._ch == -2)) {
                this._FetchNextInput();
                if ((this._ch == -1)) {
                    this._state = -2;
                    return false;
                }
            }
            else {
                if ((this._ch == -1)) {
                    this._state = -2;
                    return false;
                }
            }
            this._token.Position = cursor_pos;
        start_dfa:

            acc = this._dfa[state];
            state = (state + 1);
            tlen = this._dfa[state];
            state = (state + 1);
            for (i = 0; (i < tlen); i = (i + 1)) {
                tto = this._dfa[state];
                state = (state + 1);
                prlen = this._dfa[state];
                state = (state + 1);
                for (j = 0; (j < prlen); j = (j + 1)) {
                    pmin = this._dfa[state];
                    state = (state + 1);
                    pmax = this._dfa[state];
                    state = (state + 1);
                    if ((this._ch < pmin)) {
                        state = (state 
                                    + ((prlen 
                                    - (j + 1)) 
                                    * 2));
                        j = prlen;
                    }
                    else {
                        if ((this._ch <= pmax)) {
                            this._capture.Append(char.ConvertFromUtf32(this._ch));
                            this._FetchNextInput();
                            state = tto;
                            goto start_dfa;
                        }
                    }
                }
            }
            if ((false 
                        == (acc == -1))) {
                int sym = acc;
                int[] be = this._blockEnds[acc];
                if ((be != null)) {
                    state = 0;
                start_be_dfa:

                    acc = be[state];
                    state = (state + 1);
                    tlen = be[state];
                    state = (state + 1);
                    for (i = 0; (i < tlen); i = (i + 1)) {
                        tto = be[state];
                        state = (state + 1);
                        prlen = be[state];
                        state = (state + 1);
                        for (j = 0; (j < prlen); j = (j + 1)) {
                            pmin = be[state];
                            state = (state + 1);
                            pmax = be[state];
                            state = (state + 1);
                            if ((this._ch < pmin)) {
                                state = (state 
                                            + ((prlen 
                                            - (j + 1)) 
                                            * 2));
                                j = prlen;
                            }
                            else {
                                if ((this._ch <= pmax)) {
                                    this._capture.Append(char.ConvertFromUtf32(this._ch));
                                    this._FetchNextInput();
                                    state = tto;
                                    goto start_be_dfa;
                                }
                            }
                        }
                    }
                    if ((false 
                                == (acc == -1))) {
                        this._token.SymbolId = sym;
                        this._token.Value = this._capture.ToString();
                        this._token.AbsoluteIndex = absi;
                        this._token.Position = cursor_pos;
                        this._token.Line = line;
                        this._token.Column = column;
                        this._capture.Clear();
                        return true;
                    }
                    if ((this._ch == -1)) {
                        this._token.SymbolId = -1;
                        this._token.Value = this._capture.ToString();
                        this._token.AbsoluteIndex = absi;
                        this._token.Position = cursor_pos;
                        this._token.Line = line;
                        this._token.Column = column;
                        this._capture.Clear();
                        return false;
                    }
                    this._capture.Append(char.ConvertFromUtf32(this._ch));
                    this._FetchNextInput();
                    state = 0;
                    goto start_be_dfa;
                }
                this._token.SymbolId = acc;
                this._token.Value = this._capture.ToString();
                this._token.AbsoluteIndex = absi;
                this._token.Position = cursor_pos;
                this._token.Line = line;
                this._token.Column = column;
                this._capture.Clear();
                return true;
            }
            bool fetch = (this._capture.Length == 0);
            if (fetch) {
                this._capture.Append(char.ConvertFromUtf32(this._ch));
            }
            this._token.SymbolId = -1;
            this._token.Value = this._capture.ToString();
            this._token.AbsoluteIndex = absi;
            this._token.Position = cursor_pos;
            this._token.Line = line;
            this._token.Column = column;
            this._capture.Clear();
            if (fetch) {
                this._FetchNextInput();
            }
            return false;
        }
    }
    ///  <summary>
    ///  A table driven tokenizer
    ///  </summary>
    internal class ExampleTokenizer : TableTokenizer {
        internal static int[] DfaTable = new int[] {
                -1,
                6,
                32,
                2,
                9,
                13,
                32,
                32,
                34,
                1,
                45,
                45,
                46,
                1,
                47,
                47,
                66,
                1,
                48,
                48,
                40,
                1,
                49,
                57,
                68,
                3,
                65,
                90,
                95,
                95,
                97,
                122,
                2,
                0,
                -1,
                1,
                40,
                1,
                49,
                57,
                1,
                1,
                40,
                1,
                48,
                57,
                -1,
                2,
                56,
                1,
                42,
                42,
                58,
                1,
                47,
                47,
                4,
                0,
                3,
                1,
                58,
                2,
                0,
                9,
                11,
                1114111,
                1,
                0,
                0,
                1,
                68,
                4,
                48,
                57,
                65,
                90,
                95,
                95,
                97,
                122};
        internal static int[] NodeFlags = new int[] {
                0,
                0,
                1,
                1,
                1};
        internal static int[][] BlockEnds = new int[][] {
                null,
                null,
                null,
                null,
                new int[] {
                        -1,
                        1,
                        6,
                        1,
                        42,
                        42,
                        -1,
                        1,
                        12,
                        1,
                        47,
                        47,
                        4,
                        0}};
        ///  <summary>
        ///  Constructs a new table tokenizer
        ///  </summary>
        ///  <param name="input">The input character stream</param>
        public ExampleTokenizer(IEnumerable<char> input) : 
                base(ExampleTokenizer.DfaTable, ExampleTokenizer.BlockEnds, ExampleTokenizer.NodeFlags, input) {
        }
        ///  <summary>
        ///  Constructs a new table tokenizer
        ///  </summary>
        ///  <param name="input">The input character stream</param>
        public ExampleTokenizer(TextReader input) : 
                base(ExampleTokenizer.DfaTable, ExampleTokenizer.BlockEnds, ExampleTokenizer.NodeFlags, new TextReaderEnumerable(input)) {
        }
        /// <summary>Matches '[A-Z_a-z][0-9A-Z_a-z]*'</summary>
        public const int id = 0;
        /// <summary>Matches '0|\-?[1-9][0-9]*'</summary>
        public const int @int = 1;
        /// <summary>Matches '[\r\n\t\v\f ]'</summary>
        public const int space = 2;
        /// <summary>Matches '\/\/[^\n]*'</summary>
        public const int lineComment = 3;
        /// <summary>Matches "/*"</summary>
        public const int blockComment = 4;
    }
}
